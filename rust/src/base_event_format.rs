// This file is generated by rust-protobuf 3.0.0-alpha.10. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `base_event_format.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_ALPHA_10;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:event.Event)
pub struct Event {
    // message fields
    // @@protoc_insertion_point(field:event.Event.event_id)
    pub event_id: ::protobuf::EnumOrUnknown<EventType>,
    // message oneof groups
    pub data: ::std::option::Option<event::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:event.Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // .p2p.ChargingStatusData charging_status_data = 2;

    pub fn charging_status_data(&self) -> &super::p2p_message_format::ChargingStatusData {
        match self.data {
            ::std::option::Option::Some(event::Data::ChargingStatusData(ref v)) => v,
            _ => <super::p2p_message_format::ChargingStatusData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_charging_status_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_charging_status_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::ChargingStatusData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_charging_status_data(&mut self, v: super::p2p_message_format::ChargingStatusData) {
        self.data = ::std::option::Option::Some(event::Data::ChargingStatusData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_charging_status_data(&mut self) -> &mut super::p2p_message_format::ChargingStatusData {
        if let ::std::option::Option::Some(event::Data::ChargingStatusData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::ChargingStatusData(super::p2p_message_format::ChargingStatusData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::ChargingStatusData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_charging_status_data(&mut self) -> super::p2p_message_format::ChargingStatusData {
        if self.has_charging_status_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::ChargingStatusData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::ChargingStatusData::new()
        }
    }

    // .p2p.ServiceAckData service_ack_data = 3;

    pub fn service_ack_data(&self) -> &super::p2p_message_format::ServiceAckData {
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceAckData(ref v)) => v,
            _ => <super::p2p_message_format::ServiceAckData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_service_ack_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_service_ack_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceAckData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service_ack_data(&mut self, v: super::p2p_message_format::ServiceAckData) {
        self.data = ::std::option::Option::Some(event::Data::ServiceAckData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_service_ack_data(&mut self) -> &mut super::p2p_message_format::ServiceAckData {
        if let ::std::option::Option::Some(event::Data::ServiceAckData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::ServiceAckData(super::p2p_message_format::ServiceAckData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceAckData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_service_ack_data(&mut self) -> super::p2p_message_format::ServiceAckData {
        if self.has_service_ack_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::ServiceAckData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::ServiceAckData::new()
        }
    }

    // .p2p.ServiceRequestedData service_requested_data = 4;

    pub fn service_requested_data(&self) -> &super::p2p_message_format::ServiceRequestedData {
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceRequestedData(ref v)) => v,
            _ => <super::p2p_message_format::ServiceRequestedData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_service_requested_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_service_requested_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceRequestedData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service_requested_data(&mut self, v: super::p2p_message_format::ServiceRequestedData) {
        self.data = ::std::option::Option::Some(event::Data::ServiceRequestedData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_service_requested_data(&mut self) -> &mut super::p2p_message_format::ServiceRequestedData {
        if let ::std::option::Option::Some(event::Data::ServiceRequestedData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::ServiceRequestedData(super::p2p_message_format::ServiceRequestedData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceRequestedData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_service_requested_data(&mut self) -> super::p2p_message_format::ServiceRequestedData {
        if self.has_service_requested_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::ServiceRequestedData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::ServiceRequestedData::new()
        }
    }

    // .p2p.ServiceDeliveredData service_delivered_data = 5;

    pub fn service_delivered_data(&self) -> &super::p2p_message_format::ServiceDeliveredData {
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceDeliveredData(ref v)) => v,
            _ => <super::p2p_message_format::ServiceDeliveredData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_service_delivered_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_service_delivered_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceDeliveredData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service_delivered_data(&mut self, v: super::p2p_message_format::ServiceDeliveredData) {
        self.data = ::std::option::Option::Some(event::Data::ServiceDeliveredData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_service_delivered_data(&mut self) -> &mut super::p2p_message_format::ServiceDeliveredData {
        if let ::std::option::Option::Some(event::Data::ServiceDeliveredData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::ServiceDeliveredData(super::p2p_message_format::ServiceDeliveredData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceDeliveredData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_service_delivered_data(&mut self) -> super::p2p_message_format::ServiceDeliveredData {
        if self.has_service_delivered_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::ServiceDeliveredData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::ServiceDeliveredData::new()
        }
    }

    // .p2p.StopChargeData stop_charge_data = 6;

    pub fn stop_charge_data(&self) -> &super::p2p_message_format::StopChargeData {
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeData(ref v)) => v,
            _ => <super::p2p_message_format::StopChargeData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stop_charge_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_stop_charge_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop_charge_data(&mut self, v: super::p2p_message_format::StopChargeData) {
        self.data = ::std::option::Option::Some(event::Data::StopChargeData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stop_charge_data(&mut self) -> &mut super::p2p_message_format::StopChargeData {
        if let ::std::option::Option::Some(event::Data::StopChargeData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::StopChargeData(super::p2p_message_format::StopChargeData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stop_charge_data(&mut self) -> super::p2p_message_format::StopChargeData {
        if self.has_stop_charge_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::StopChargeData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::StopChargeData::new()
        }
    }

    // .p2p.StopChargeResponseData stop_charge_resp_data = 7;

    pub fn stop_charge_resp_data(&self) -> &super::p2p_message_format::StopChargeResponseData {
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeRespData(ref v)) => v,
            _ => <super::p2p_message_format::StopChargeResponseData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stop_charge_resp_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_stop_charge_resp_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeRespData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop_charge_resp_data(&mut self, v: super::p2p_message_format::StopChargeResponseData) {
        self.data = ::std::option::Option::Some(event::Data::StopChargeRespData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stop_charge_resp_data(&mut self) -> &mut super::p2p_message_format::StopChargeResponseData {
        if let ::std::option::Option::Some(event::Data::StopChargeRespData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::StopChargeRespData(super::p2p_message_format::StopChargeResponseData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeRespData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stop_charge_resp_data(&mut self) -> super::p2p_message_format::StopChargeResponseData {
        if self.has_stop_charge_resp_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::StopChargeRespData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::StopChargeResponseData::new()
        }
    }

    // .p2p.IdentityChallengeData identity_challenge_data = 8;

    pub fn identity_challenge_data(&self) -> &super::p2p_message_format::IdentityChallengeData {
        match self.data {
            ::std::option::Option::Some(event::Data::IdentityChallengeData(ref v)) => v,
            _ => <super::p2p_message_format::IdentityChallengeData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_identity_challenge_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_identity_challenge_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::IdentityChallengeData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_identity_challenge_data(&mut self, v: super::p2p_message_format::IdentityChallengeData) {
        self.data = ::std::option::Option::Some(event::Data::IdentityChallengeData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_identity_challenge_data(&mut self) -> &mut super::p2p_message_format::IdentityChallengeData {
        if let ::std::option::Option::Some(event::Data::IdentityChallengeData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::IdentityChallengeData(super::p2p_message_format::IdentityChallengeData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::IdentityChallengeData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_identity_challenge_data(&mut self) -> super::p2p_message_format::IdentityChallengeData {
        if self.has_identity_challenge_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::IdentityChallengeData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::IdentityChallengeData::new()
        }
    }

    // .p2p.IdentityResponseData identity_response_data = 9;

    pub fn identity_response_data(&self) -> &super::p2p_message_format::IdentityResponseData {
        match self.data {
            ::std::option::Option::Some(event::Data::IdentityResponseData(ref v)) => v,
            _ => <super::p2p_message_format::IdentityResponseData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_identity_response_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_identity_response_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::IdentityResponseData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_identity_response_data(&mut self, v: super::p2p_message_format::IdentityResponseData) {
        self.data = ::std::option::Option::Some(event::Data::IdentityResponseData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_identity_response_data(&mut self) -> &mut super::p2p_message_format::IdentityResponseData {
        if let ::std::option::Option::Some(event::Data::IdentityResponseData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::IdentityResponseData(super::p2p_message_format::IdentityResponseData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::IdentityResponseData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_identity_response_data(&mut self) -> super::p2p_message_format::IdentityResponseData {
        if self.has_identity_response_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::IdentityResponseData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::IdentityResponseData::new()
        }
    }

    // .p2p.ChainEventData chain_event_data = 10;

    pub fn chain_event_data(&self) -> &super::p2p_message_format::ChainEventData {
        match self.data {
            ::std::option::Option::Some(event::Data::ChainEventData(ref v)) => v,
            _ => <super::p2p_message_format::ChainEventData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_chain_event_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_chain_event_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::ChainEventData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chain_event_data(&mut self, v: super::p2p_message_format::ChainEventData) {
        self.data = ::std::option::Option::Some(event::Data::ChainEventData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chain_event_data(&mut self) -> &mut super::p2p_message_format::ChainEventData {
        if let ::std::option::Option::Some(event::Data::ChainEventData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::ChainEventData(super::p2p_message_format::ChainEventData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::ChainEventData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chain_event_data(&mut self) -> super::p2p_message_format::ChainEventData {
        if self.has_chain_event_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::ChainEventData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::ChainEventData::new()
        }
    }

    // .p2p.EmitShowInfoData emit_show_info_data = 11;

    pub fn emit_show_info_data(&self) -> &super::p2p_message_format::EmitShowInfoData {
        match self.data {
            ::std::option::Option::Some(event::Data::EmitShowInfoData(ref v)) => v,
            _ => <super::p2p_message_format::EmitShowInfoData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_emit_show_info_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_emit_show_info_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::EmitShowInfoData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_emit_show_info_data(&mut self, v: super::p2p_message_format::EmitShowInfoData) {
        self.data = ::std::option::Option::Some(event::Data::EmitShowInfoData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_emit_show_info_data(&mut self) -> &mut super::p2p_message_format::EmitShowInfoData {
        if let ::std::option::Option::Some(event::Data::EmitShowInfoData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::EmitShowInfoData(super::p2p_message_format::EmitShowInfoData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::EmitShowInfoData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_emit_show_info_data(&mut self) -> super::p2p_message_format::EmitShowInfoData {
        if self.has_emit_show_info_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::EmitShowInfoData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::EmitShowInfoData::new()
        }
    }

    // .p2p.GetBalanceAckData get_balance_ack_data = 12;

    pub fn get_balance_ack_data(&self) -> &super::p2p_message_format::GetBalanceAckData {
        match self.data {
            ::std::option::Option::Some(event::Data::GetBalanceAckData(ref v)) => v,
            _ => <super::p2p_message_format::GetBalanceAckData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_balance_ack_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_get_balance_ack_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::GetBalanceAckData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_balance_ack_data(&mut self, v: super::p2p_message_format::GetBalanceAckData) {
        self.data = ::std::option::Option::Some(event::Data::GetBalanceAckData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_balance_ack_data(&mut self) -> &mut super::p2p_message_format::GetBalanceAckData {
        if let ::std::option::Option::Some(event::Data::GetBalanceAckData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::GetBalanceAckData(super::p2p_message_format::GetBalanceAckData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::GetBalanceAckData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_balance_ack_data(&mut self) -> super::p2p_message_format::GetBalanceAckData {
        if self.has_get_balance_ack_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::GetBalanceAckData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::GetBalanceAckData::new()
        }
    }

    // .p2p.GetPKAckData get_pk_ack_data = 13;

    pub fn get_pk_ack_data(&self) -> &super::p2p_message_format::GetPKAckData {
        match self.data {
            ::std::option::Option::Some(event::Data::GetPkAckData(ref v)) => v,
            _ => <super::p2p_message_format::GetPKAckData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_pk_ack_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_get_pk_ack_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::GetPkAckData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_pk_ack_data(&mut self, v: super::p2p_message_format::GetPKAckData) {
        self.data = ::std::option::Option::Some(event::Data::GetPkAckData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_pk_ack_data(&mut self) -> &mut super::p2p_message_format::GetPKAckData {
        if let ::std::option::Option::Some(event::Data::GetPkAckData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::GetPkAckData(super::p2p_message_format::GetPKAckData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::GetPkAckData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_pk_ack_data(&mut self) -> super::p2p_message_format::GetPKAckData {
        if self.has_get_pk_ack_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::GetPkAckData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::GetPKAckData::new()
        }
    }

    // .p2p.RePublishDIDAckData republish_ack_data = 14;

    pub fn republish_ack_data(&self) -> &super::p2p_message_format::RePublishDIDAckData {
        match self.data {
            ::std::option::Option::Some(event::Data::RepublishAckData(ref v)) => v,
            _ => <super::p2p_message_format::RePublishDIDAckData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_republish_ack_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_republish_ack_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::RepublishAckData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_republish_ack_data(&mut self, v: super::p2p_message_format::RePublishDIDAckData) {
        self.data = ::std::option::Option::Some(event::Data::RepublishAckData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_republish_ack_data(&mut self) -> &mut super::p2p_message_format::RePublishDIDAckData {
        if let ::std::option::Option::Some(event::Data::RepublishAckData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::RepublishAckData(super::p2p_message_format::RePublishDIDAckData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::RepublishAckData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_republish_ack_data(&mut self) -> super::p2p_message_format::RePublishDIDAckData {
        if self.has_republish_ack_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::RepublishAckData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::RePublishDIDAckData::new()
        }
    }

    // .p2p.ReconnectAckData reconnect_ack_data = 15;

    pub fn reconnect_ack_data(&self) -> &super::p2p_message_format::ReconnectAckData {
        match self.data {
            ::std::option::Option::Some(event::Data::ReconnectAckData(ref v)) => v,
            _ => <super::p2p_message_format::ReconnectAckData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_reconnect_ack_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_reconnect_ack_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::ReconnectAckData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reconnect_ack_data(&mut self, v: super::p2p_message_format::ReconnectAckData) {
        self.data = ::std::option::Option::Some(event::Data::ReconnectAckData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reconnect_ack_data(&mut self) -> &mut super::p2p_message_format::ReconnectAckData {
        if let ::std::option::Option::Some(event::Data::ReconnectAckData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::ReconnectAckData(super::p2p_message_format::ReconnectAckData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::ReconnectAckData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reconnect_ack_data(&mut self) -> super::p2p_message_format::ReconnectAckData {
        if self.has_reconnect_ack_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::ReconnectAckData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::ReconnectAckData::new()
        }
    }

    // .p2p.ServiceRequestedAckData service_requested_ack_data = 16;

    pub fn service_requested_ack_data(&self) -> &super::p2p_message_format::ServiceRequestedAckData {
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceRequestedAckData(ref v)) => v,
            _ => <super::p2p_message_format::ServiceRequestedAckData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_service_requested_ack_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_service_requested_ack_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceRequestedAckData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service_requested_ack_data(&mut self, v: super::p2p_message_format::ServiceRequestedAckData) {
        self.data = ::std::option::Option::Some(event::Data::ServiceRequestedAckData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_service_requested_ack_data(&mut self) -> &mut super::p2p_message_format::ServiceRequestedAckData {
        if let ::std::option::Option::Some(event::Data::ServiceRequestedAckData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::ServiceRequestedAckData(super::p2p_message_format::ServiceRequestedAckData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::ServiceRequestedAckData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_service_requested_ack_data(&mut self) -> super::p2p_message_format::ServiceRequestedAckData {
        if self.has_service_requested_ack_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::ServiceRequestedAckData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::p2p_message_format::ServiceRequestedAckData::new()
        }
    }

    // .gateway.BootNotificationRequestData boot_notification_request_data = 17;

    pub fn boot_notification_request_data(&self) -> &super::charge_point_gateway_format::BootNotificationRequestData {
        match self.data {
            ::std::option::Option::Some(event::Data::BootNotificationRequestData(ref v)) => v,
            _ => <super::charge_point_gateway_format::BootNotificationRequestData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_boot_notification_request_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_boot_notification_request_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::BootNotificationRequestData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boot_notification_request_data(&mut self, v: super::charge_point_gateway_format::BootNotificationRequestData) {
        self.data = ::std::option::Option::Some(event::Data::BootNotificationRequestData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_boot_notification_request_data(&mut self) -> &mut super::charge_point_gateway_format::BootNotificationRequestData {
        if let ::std::option::Option::Some(event::Data::BootNotificationRequestData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::BootNotificationRequestData(super::charge_point_gateway_format::BootNotificationRequestData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::BootNotificationRequestData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_boot_notification_request_data(&mut self) -> super::charge_point_gateway_format::BootNotificationRequestData {
        if self.has_boot_notification_request_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::BootNotificationRequestData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::BootNotificationRequestData::new()
        }
    }

    // .gateway.LogData log_data = 18;

    pub fn log_data(&self) -> &super::charge_point_gateway_format::LogData {
        match self.data {
            ::std::option::Option::Some(event::Data::LogData(ref v)) => v,
            _ => <super::charge_point_gateway_format::LogData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_log_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_log_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::LogData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_log_data(&mut self, v: super::charge_point_gateway_format::LogData) {
        self.data = ::std::option::Option::Some(event::Data::LogData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_log_data(&mut self) -> &mut super::charge_point_gateway_format::LogData {
        if let ::std::option::Option::Some(event::Data::LogData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::LogData(super::charge_point_gateway_format::LogData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::LogData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_log_data(&mut self) -> super::charge_point_gateway_format::LogData {
        if self.has_log_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::LogData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::LogData::new()
        }
    }

    // .gateway.AuthorizeRequestData authorize_request_data = 19;

    pub fn authorize_request_data(&self) -> &super::charge_point_gateway_format::AuthorizeRequestData {
        match self.data {
            ::std::option::Option::Some(event::Data::AuthorizeRequestData(ref v)) => v,
            _ => <super::charge_point_gateway_format::AuthorizeRequestData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_authorize_request_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_authorize_request_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::AuthorizeRequestData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_authorize_request_data(&mut self, v: super::charge_point_gateway_format::AuthorizeRequestData) {
        self.data = ::std::option::Option::Some(event::Data::AuthorizeRequestData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_authorize_request_data(&mut self) -> &mut super::charge_point_gateway_format::AuthorizeRequestData {
        if let ::std::option::Option::Some(event::Data::AuthorizeRequestData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::AuthorizeRequestData(super::charge_point_gateway_format::AuthorizeRequestData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::AuthorizeRequestData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_authorize_request_data(&mut self) -> super::charge_point_gateway_format::AuthorizeRequestData {
        if self.has_authorize_request_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::AuthorizeRequestData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::AuthorizeRequestData::new()
        }
    }

    // .gateway.AuthorizeResponseData authorize_response_data = 20;

    pub fn authorize_response_data(&self) -> &super::charge_point_gateway_format::AuthorizeResponseData {
        match self.data {
            ::std::option::Option::Some(event::Data::AuthorizeResponseData(ref v)) => v,
            _ => <super::charge_point_gateway_format::AuthorizeResponseData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_authorize_response_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_authorize_response_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::AuthorizeResponseData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_authorize_response_data(&mut self, v: super::charge_point_gateway_format::AuthorizeResponseData) {
        self.data = ::std::option::Option::Some(event::Data::AuthorizeResponseData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_authorize_response_data(&mut self) -> &mut super::charge_point_gateway_format::AuthorizeResponseData {
        if let ::std::option::Option::Some(event::Data::AuthorizeResponseData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::AuthorizeResponseData(super::charge_point_gateway_format::AuthorizeResponseData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::AuthorizeResponseData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_authorize_response_data(&mut self) -> super::charge_point_gateway_format::AuthorizeResponseData {
        if self.has_authorize_response_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::AuthorizeResponseData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::AuthorizeResponseData::new()
        }
    }

    // .gateway.CheckAvailabilityRequestData check_availability_request_data = 21;

    pub fn check_availability_request_data(&self) -> &super::charge_point_gateway_format::CheckAvailabilityRequestData {
        match self.data {
            ::std::option::Option::Some(event::Data::CheckAvailabilityRequestData(ref v)) => v,
            _ => <super::charge_point_gateway_format::CheckAvailabilityRequestData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_check_availability_request_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_check_availability_request_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::CheckAvailabilityRequestData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_check_availability_request_data(&mut self, v: super::charge_point_gateway_format::CheckAvailabilityRequestData) {
        self.data = ::std::option::Option::Some(event::Data::CheckAvailabilityRequestData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_check_availability_request_data(&mut self) -> &mut super::charge_point_gateway_format::CheckAvailabilityRequestData {
        if let ::std::option::Option::Some(event::Data::CheckAvailabilityRequestData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::CheckAvailabilityRequestData(super::charge_point_gateway_format::CheckAvailabilityRequestData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::CheckAvailabilityRequestData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_check_availability_request_data(&mut self) -> super::charge_point_gateway_format::CheckAvailabilityRequestData {
        if self.has_check_availability_request_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::CheckAvailabilityRequestData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::CheckAvailabilityRequestData::new()
        }
    }

    // .gateway.CheckAvailabilityResponseData check_availability_response_data = 22;

    pub fn check_availability_response_data(&self) -> &super::charge_point_gateway_format::CheckAvailabilityResponseData {
        match self.data {
            ::std::option::Option::Some(event::Data::CheckAvailabilityResponseData(ref v)) => v,
            _ => <super::charge_point_gateway_format::CheckAvailabilityResponseData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_check_availability_response_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_check_availability_response_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::CheckAvailabilityResponseData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_check_availability_response_data(&mut self, v: super::charge_point_gateway_format::CheckAvailabilityResponseData) {
        self.data = ::std::option::Option::Some(event::Data::CheckAvailabilityResponseData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_check_availability_response_data(&mut self) -> &mut super::charge_point_gateway_format::CheckAvailabilityResponseData {
        if let ::std::option::Option::Some(event::Data::CheckAvailabilityResponseData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::CheckAvailabilityResponseData(super::charge_point_gateway_format::CheckAvailabilityResponseData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::CheckAvailabilityResponseData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_check_availability_response_data(&mut self) -> super::charge_point_gateway_format::CheckAvailabilityResponseData {
        if self.has_check_availability_response_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::CheckAvailabilityResponseData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::CheckAvailabilityResponseData::new()
        }
    }

    // .gateway.StartChargeRequestData start_charge_request_data = 24;

    pub fn start_charge_request_data(&self) -> &super::charge_point_gateway_format::StartChargeRequestData {
        match self.data {
            ::std::option::Option::Some(event::Data::StartChargeRequestData(ref v)) => v,
            _ => <super::charge_point_gateway_format::StartChargeRequestData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_start_charge_request_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_start_charge_request_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::StartChargeRequestData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_charge_request_data(&mut self, v: super::charge_point_gateway_format::StartChargeRequestData) {
        self.data = ::std::option::Option::Some(event::Data::StartChargeRequestData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_charge_request_data(&mut self) -> &mut super::charge_point_gateway_format::StartChargeRequestData {
        if let ::std::option::Option::Some(event::Data::StartChargeRequestData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::StartChargeRequestData(super::charge_point_gateway_format::StartChargeRequestData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::StartChargeRequestData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_charge_request_data(&mut self) -> super::charge_point_gateway_format::StartChargeRequestData {
        if self.has_start_charge_request_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::StartChargeRequestData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::StartChargeRequestData::new()
        }
    }

    // .gateway.StartChargeResponseData start_charge_response_data = 25;

    pub fn start_charge_response_data(&self) -> &super::charge_point_gateway_format::StartChargeResponseData {
        match self.data {
            ::std::option::Option::Some(event::Data::StartChargeResponseData(ref v)) => v,
            _ => <super::charge_point_gateway_format::StartChargeResponseData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_start_charge_response_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_start_charge_response_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::StartChargeResponseData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_charge_response_data(&mut self, v: super::charge_point_gateway_format::StartChargeResponseData) {
        self.data = ::std::option::Option::Some(event::Data::StartChargeResponseData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_charge_response_data(&mut self) -> &mut super::charge_point_gateway_format::StartChargeResponseData {
        if let ::std::option::Option::Some(event::Data::StartChargeResponseData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::StartChargeResponseData(super::charge_point_gateway_format::StartChargeResponseData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::StartChargeResponseData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_charge_response_data(&mut self) -> super::charge_point_gateway_format::StartChargeResponseData {
        if self.has_start_charge_response_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::StartChargeResponseData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::StartChargeResponseData::new()
        }
    }

    // .gateway.EVChargingStatusData ev_charge_status_data = 26;

    pub fn ev_charge_status_data(&self) -> &super::charge_point_gateway_format::EVChargingStatusData {
        match self.data {
            ::std::option::Option::Some(event::Data::EvChargeStatusData(ref v)) => v,
            _ => <super::charge_point_gateway_format::EVChargingStatusData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ev_charge_status_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_ev_charge_status_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::EvChargeStatusData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ev_charge_status_data(&mut self, v: super::charge_point_gateway_format::EVChargingStatusData) {
        self.data = ::std::option::Option::Some(event::Data::EvChargeStatusData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ev_charge_status_data(&mut self) -> &mut super::charge_point_gateway_format::EVChargingStatusData {
        if let ::std::option::Option::Some(event::Data::EvChargeStatusData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::EvChargeStatusData(super::charge_point_gateway_format::EVChargingStatusData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::EvChargeStatusData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ev_charge_status_data(&mut self) -> super::charge_point_gateway_format::EVChargingStatusData {
        if self.has_ev_charge_status_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::EvChargeStatusData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::EVChargingStatusData::new()
        }
    }

    // .gateway.StopChargeRequestData stop_charge_request_data = 27;

    pub fn stop_charge_request_data(&self) -> &super::charge_point_gateway_format::StopChargeRequestData {
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeRequestData(ref v)) => v,
            _ => <super::charge_point_gateway_format::StopChargeRequestData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stop_charge_request_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_stop_charge_request_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeRequestData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop_charge_request_data(&mut self, v: super::charge_point_gateway_format::StopChargeRequestData) {
        self.data = ::std::option::Option::Some(event::Data::StopChargeRequestData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stop_charge_request_data(&mut self) -> &mut super::charge_point_gateway_format::StopChargeRequestData {
        if let ::std::option::Option::Some(event::Data::StopChargeRequestData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::StopChargeRequestData(super::charge_point_gateway_format::StopChargeRequestData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeRequestData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stop_charge_request_data(&mut self) -> super::charge_point_gateway_format::StopChargeRequestData {
        if self.has_stop_charge_request_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::StopChargeRequestData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::StopChargeRequestData::new()
        }
    }

    // .gateway.StopChargeResponseData stop_charge_response_data = 28;

    pub fn stop_charge_response_data(&self) -> &super::charge_point_gateway_format::StopChargeResponseData {
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeResponseData(ref v)) => v,
            _ => <super::charge_point_gateway_format::StopChargeResponseData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stop_charge_response_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_stop_charge_response_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeResponseData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop_charge_response_data(&mut self, v: super::charge_point_gateway_format::StopChargeResponseData) {
        self.data = ::std::option::Option::Some(event::Data::StopChargeResponseData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stop_charge_response_data(&mut self) -> &mut super::charge_point_gateway_format::StopChargeResponseData {
        if let ::std::option::Option::Some(event::Data::StopChargeResponseData(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(event::Data::StopChargeResponseData(super::charge_point_gateway_format::StopChargeResponseData::new()));
        }
        match self.data {
            ::std::option::Option::Some(event::Data::StopChargeResponseData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stop_charge_response_data(&mut self) -> super::charge_point_gateway_format::StopChargeResponseData {
        if self.has_stop_charge_response_data() {
            match self.data.take() {
                ::std::option::Option::Some(event::Data::StopChargeResponseData(v)) => v,
                _ => panic!(),
            }
        } else {
            super::charge_point_gateway_format::StopChargeResponseData::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_id",
            |m: &Event| { &m.event_id },
            |m: &mut Event| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::ChargingStatusData>(
            "charging_status_data",
            Event::has_charging_status_data,
            Event::charging_status_data,
            Event::mut_charging_status_data,
            Event::set_charging_status_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::ServiceAckData>(
            "service_ack_data",
            Event::has_service_ack_data,
            Event::service_ack_data,
            Event::mut_service_ack_data,
            Event::set_service_ack_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::ServiceRequestedData>(
            "service_requested_data",
            Event::has_service_requested_data,
            Event::service_requested_data,
            Event::mut_service_requested_data,
            Event::set_service_requested_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::ServiceDeliveredData>(
            "service_delivered_data",
            Event::has_service_delivered_data,
            Event::service_delivered_data,
            Event::mut_service_delivered_data,
            Event::set_service_delivered_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::StopChargeData>(
            "stop_charge_data",
            Event::has_stop_charge_data,
            Event::stop_charge_data,
            Event::mut_stop_charge_data,
            Event::set_stop_charge_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::StopChargeResponseData>(
            "stop_charge_resp_data",
            Event::has_stop_charge_resp_data,
            Event::stop_charge_resp_data,
            Event::mut_stop_charge_resp_data,
            Event::set_stop_charge_resp_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::IdentityChallengeData>(
            "identity_challenge_data",
            Event::has_identity_challenge_data,
            Event::identity_challenge_data,
            Event::mut_identity_challenge_data,
            Event::set_identity_challenge_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::IdentityResponseData>(
            "identity_response_data",
            Event::has_identity_response_data,
            Event::identity_response_data,
            Event::mut_identity_response_data,
            Event::set_identity_response_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::ChainEventData>(
            "chain_event_data",
            Event::has_chain_event_data,
            Event::chain_event_data,
            Event::mut_chain_event_data,
            Event::set_chain_event_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::EmitShowInfoData>(
            "emit_show_info_data",
            Event::has_emit_show_info_data,
            Event::emit_show_info_data,
            Event::mut_emit_show_info_data,
            Event::set_emit_show_info_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::GetBalanceAckData>(
            "get_balance_ack_data",
            Event::has_get_balance_ack_data,
            Event::get_balance_ack_data,
            Event::mut_get_balance_ack_data,
            Event::set_get_balance_ack_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::GetPKAckData>(
            "get_pk_ack_data",
            Event::has_get_pk_ack_data,
            Event::get_pk_ack_data,
            Event::mut_get_pk_ack_data,
            Event::set_get_pk_ack_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::RePublishDIDAckData>(
            "republish_ack_data",
            Event::has_republish_ack_data,
            Event::republish_ack_data,
            Event::mut_republish_ack_data,
            Event::set_republish_ack_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::ReconnectAckData>(
            "reconnect_ack_data",
            Event::has_reconnect_ack_data,
            Event::reconnect_ack_data,
            Event::mut_reconnect_ack_data,
            Event::set_reconnect_ack_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::p2p_message_format::ServiceRequestedAckData>(
            "service_requested_ack_data",
            Event::has_service_requested_ack_data,
            Event::service_requested_ack_data,
            Event::mut_service_requested_ack_data,
            Event::set_service_requested_ack_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::BootNotificationRequestData>(
            "boot_notification_request_data",
            Event::has_boot_notification_request_data,
            Event::boot_notification_request_data,
            Event::mut_boot_notification_request_data,
            Event::set_boot_notification_request_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::LogData>(
            "log_data",
            Event::has_log_data,
            Event::log_data,
            Event::mut_log_data,
            Event::set_log_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::AuthorizeRequestData>(
            "authorize_request_data",
            Event::has_authorize_request_data,
            Event::authorize_request_data,
            Event::mut_authorize_request_data,
            Event::set_authorize_request_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::AuthorizeResponseData>(
            "authorize_response_data",
            Event::has_authorize_response_data,
            Event::authorize_response_data,
            Event::mut_authorize_response_data,
            Event::set_authorize_response_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::CheckAvailabilityRequestData>(
            "check_availability_request_data",
            Event::has_check_availability_request_data,
            Event::check_availability_request_data,
            Event::mut_check_availability_request_data,
            Event::set_check_availability_request_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::CheckAvailabilityResponseData>(
            "check_availability_response_data",
            Event::has_check_availability_response_data,
            Event::check_availability_response_data,
            Event::mut_check_availability_response_data,
            Event::set_check_availability_response_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::StartChargeRequestData>(
            "start_charge_request_data",
            Event::has_start_charge_request_data,
            Event::start_charge_request_data,
            Event::mut_start_charge_request_data,
            Event::set_start_charge_request_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::StartChargeResponseData>(
            "start_charge_response_data",
            Event::has_start_charge_response_data,
            Event::start_charge_response_data,
            Event::mut_start_charge_response_data,
            Event::set_start_charge_response_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::EVChargingStatusData>(
            "ev_charge_status_data",
            Event::has_ev_charge_status_data,
            Event::ev_charge_status_data,
            Event::mut_ev_charge_status_data,
            Event::set_ev_charge_status_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::StopChargeRequestData>(
            "stop_charge_request_data",
            Event::has_stop_charge_request_data,
            Event::stop_charge_request_data,
            Event::mut_stop_charge_request_data,
            Event::set_stop_charge_request_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::charge_point_gateway_format::StopChargeResponseData>(
            "stop_charge_response_data",
            Event::has_stop_charge_response_data,
            Event::stop_charge_response_data,
            Event::mut_stop_charge_response_data,
            Event::set_stop_charge_response_data,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new::<Event>(
            "Event",
            fields,
        )
    }
}

impl ::protobuf::Message for Event {
    const NAME: &'static str = "Event";

    fn is_initialized(&self) -> bool {
        if let Some(event::Data::ChargingStatusData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::ServiceAckData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::ServiceRequestedData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::ServiceDeliveredData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::StopChargeData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::StopChargeRespData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::IdentityChallengeData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::IdentityResponseData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::ChainEventData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::EmitShowInfoData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::GetBalanceAckData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::GetPkAckData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::RepublishAckData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::ReconnectAckData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::ServiceRequestedAckData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::BootNotificationRequestData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::LogData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::AuthorizeRequestData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::AuthorizeResponseData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::CheckAvailabilityRequestData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::CheckAvailabilityResponseData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::StartChargeRequestData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::StartChargeResponseData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::EvChargeStatusData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::StopChargeRequestData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(event::Data::StopChargeResponseData(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.data = ::std::option::Option::Some(event::Data::ChargingStatusData(is.read_message()?));
                },
                26 => {
                    self.data = ::std::option::Option::Some(event::Data::ServiceAckData(is.read_message()?));
                },
                34 => {
                    self.data = ::std::option::Option::Some(event::Data::ServiceRequestedData(is.read_message()?));
                },
                42 => {
                    self.data = ::std::option::Option::Some(event::Data::ServiceDeliveredData(is.read_message()?));
                },
                50 => {
                    self.data = ::std::option::Option::Some(event::Data::StopChargeData(is.read_message()?));
                },
                58 => {
                    self.data = ::std::option::Option::Some(event::Data::StopChargeRespData(is.read_message()?));
                },
                66 => {
                    self.data = ::std::option::Option::Some(event::Data::IdentityChallengeData(is.read_message()?));
                },
                74 => {
                    self.data = ::std::option::Option::Some(event::Data::IdentityResponseData(is.read_message()?));
                },
                82 => {
                    self.data = ::std::option::Option::Some(event::Data::ChainEventData(is.read_message()?));
                },
                90 => {
                    self.data = ::std::option::Option::Some(event::Data::EmitShowInfoData(is.read_message()?));
                },
                98 => {
                    self.data = ::std::option::Option::Some(event::Data::GetBalanceAckData(is.read_message()?));
                },
                106 => {
                    self.data = ::std::option::Option::Some(event::Data::GetPkAckData(is.read_message()?));
                },
                114 => {
                    self.data = ::std::option::Option::Some(event::Data::RepublishAckData(is.read_message()?));
                },
                122 => {
                    self.data = ::std::option::Option::Some(event::Data::ReconnectAckData(is.read_message()?));
                },
                130 => {
                    self.data = ::std::option::Option::Some(event::Data::ServiceRequestedAckData(is.read_message()?));
                },
                138 => {
                    self.data = ::std::option::Option::Some(event::Data::BootNotificationRequestData(is.read_message()?));
                },
                146 => {
                    self.data = ::std::option::Option::Some(event::Data::LogData(is.read_message()?));
                },
                154 => {
                    self.data = ::std::option::Option::Some(event::Data::AuthorizeRequestData(is.read_message()?));
                },
                162 => {
                    self.data = ::std::option::Option::Some(event::Data::AuthorizeResponseData(is.read_message()?));
                },
                170 => {
                    self.data = ::std::option::Option::Some(event::Data::CheckAvailabilityRequestData(is.read_message()?));
                },
                178 => {
                    self.data = ::std::option::Option::Some(event::Data::CheckAvailabilityResponseData(is.read_message()?));
                },
                194 => {
                    self.data = ::std::option::Option::Some(event::Data::StartChargeRequestData(is.read_message()?));
                },
                202 => {
                    self.data = ::std::option::Option::Some(event::Data::StartChargeResponseData(is.read_message()?));
                },
                210 => {
                    self.data = ::std::option::Option::Some(event::Data::EvChargeStatusData(is.read_message()?));
                },
                218 => {
                    self.data = ::std::option::Option::Some(event::Data::StopChargeRequestData(is.read_message()?));
                },
                226 => {
                    self.data = ::std::option::Option::Some(event::Data::StopChargeResponseData(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.event_id != ::protobuf::EnumOrUnknown::new(EventType::CHARGING_STATUS) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.event_id);
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &event::Data::ChargingStatusData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::ServiceAckData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::ServiceRequestedData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::ServiceDeliveredData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::StopChargeData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::StopChargeRespData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::IdentityChallengeData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::IdentityResponseData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::ChainEventData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::EmitShowInfoData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::GetBalanceAckData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::GetPkAckData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::RepublishAckData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::ReconnectAckData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::ServiceRequestedAckData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::BootNotificationRequestData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::LogData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::AuthorizeRequestData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::AuthorizeResponseData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::CheckAvailabilityRequestData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::CheckAvailabilityResponseData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::StartChargeRequestData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::StartChargeResponseData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::EvChargeStatusData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::StopChargeRequestData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &event::Data::StopChargeResponseData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.event_id != ::protobuf::EnumOrUnknown::new(EventType::CHARGING_STATUS) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.event_id))?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &event::Data::ChargingStatusData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &event::Data::ServiceAckData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &event::Data::ServiceRequestedData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &event::Data::ServiceDeliveredData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &event::Data::StopChargeData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &event::Data::StopChargeRespData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &event::Data::IdentityChallengeData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &event::Data::IdentityResponseData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &event::Data::ChainEventData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &event::Data::EmitShowInfoData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &event::Data::GetBalanceAckData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &event::Data::GetPkAckData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &event::Data::RepublishAckData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &event::Data::ReconnectAckData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &event::Data::ServiceRequestedAckData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &event::Data::BootNotificationRequestData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &event::Data::LogData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &event::Data::AuthorizeRequestData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &event::Data::AuthorizeResponseData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
                &event::Data::CheckAvailabilityRequestData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                },
                &event::Data::CheckAvailabilityResponseData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                },
                &event::Data::StartChargeRequestData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
                },
                &event::Data::StartChargeResponseData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
                },
                &event::Data::EvChargeStatusData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
                },
                &event::Data::StopChargeRequestData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
                },
                &event::Data::StopChargeResponseData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn cached_size(&self) -> u32 {
        self.special_fields.cached_size().get()
    }

    fn unknown_fields(&self) -> &::protobuf::UnknownFields {
        self.special_fields.unknown_fields()
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        self.special_fields.mut_unknown_fields()
    }

    fn new() -> Event {
        Event::new()
    }

    fn clear(&mut self) {
        self.event_id = ::protobuf::EnumOrUnknown::new(EventType::CHARGING_STATUS);
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Event {
        static instance: Event = Event {
            event_id: ::protobuf::EnumOrUnknown::from_i32(0),
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Event {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Event").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Event`
pub mod event {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:event.Event.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:event.Event.charging_status_data)
        ChargingStatusData(super::super::p2p_message_format::ChargingStatusData),
        // @@protoc_insertion_point(oneof_field:event.Event.service_ack_data)
        ServiceAckData(super::super::p2p_message_format::ServiceAckData),
        // @@protoc_insertion_point(oneof_field:event.Event.service_requested_data)
        ServiceRequestedData(super::super::p2p_message_format::ServiceRequestedData),
        // @@protoc_insertion_point(oneof_field:event.Event.service_delivered_data)
        ServiceDeliveredData(super::super::p2p_message_format::ServiceDeliveredData),
        // @@protoc_insertion_point(oneof_field:event.Event.stop_charge_data)
        StopChargeData(super::super::p2p_message_format::StopChargeData),
        // @@protoc_insertion_point(oneof_field:event.Event.stop_charge_resp_data)
        StopChargeRespData(super::super::p2p_message_format::StopChargeResponseData),
        // @@protoc_insertion_point(oneof_field:event.Event.identity_challenge_data)
        IdentityChallengeData(super::super::p2p_message_format::IdentityChallengeData),
        // @@protoc_insertion_point(oneof_field:event.Event.identity_response_data)
        IdentityResponseData(super::super::p2p_message_format::IdentityResponseData),
        // @@protoc_insertion_point(oneof_field:event.Event.chain_event_data)
        ChainEventData(super::super::p2p_message_format::ChainEventData),
        // @@protoc_insertion_point(oneof_field:event.Event.emit_show_info_data)
        EmitShowInfoData(super::super::p2p_message_format::EmitShowInfoData),
        // @@protoc_insertion_point(oneof_field:event.Event.get_balance_ack_data)
        GetBalanceAckData(super::super::p2p_message_format::GetBalanceAckData),
        // @@protoc_insertion_point(oneof_field:event.Event.get_pk_ack_data)
        GetPkAckData(super::super::p2p_message_format::GetPKAckData),
        // @@protoc_insertion_point(oneof_field:event.Event.republish_ack_data)
        RepublishAckData(super::super::p2p_message_format::RePublishDIDAckData),
        // @@protoc_insertion_point(oneof_field:event.Event.reconnect_ack_data)
        ReconnectAckData(super::super::p2p_message_format::ReconnectAckData),
        // @@protoc_insertion_point(oneof_field:event.Event.service_requested_ack_data)
        ServiceRequestedAckData(super::super::p2p_message_format::ServiceRequestedAckData),
        // @@protoc_insertion_point(oneof_field:event.Event.boot_notification_request_data)
        BootNotificationRequestData(super::super::charge_point_gateway_format::BootNotificationRequestData),
        // @@protoc_insertion_point(oneof_field:event.Event.log_data)
        LogData(super::super::charge_point_gateway_format::LogData),
        // @@protoc_insertion_point(oneof_field:event.Event.authorize_request_data)
        AuthorizeRequestData(super::super::charge_point_gateway_format::AuthorizeRequestData),
        // @@protoc_insertion_point(oneof_field:event.Event.authorize_response_data)
        AuthorizeResponseData(super::super::charge_point_gateway_format::AuthorizeResponseData),
        // @@protoc_insertion_point(oneof_field:event.Event.check_availability_request_data)
        CheckAvailabilityRequestData(super::super::charge_point_gateway_format::CheckAvailabilityRequestData),
        // @@protoc_insertion_point(oneof_field:event.Event.check_availability_response_data)
        CheckAvailabilityResponseData(super::super::charge_point_gateway_format::CheckAvailabilityResponseData),
        // @@protoc_insertion_point(oneof_field:event.Event.start_charge_request_data)
        StartChargeRequestData(super::super::charge_point_gateway_format::StartChargeRequestData),
        // @@protoc_insertion_point(oneof_field:event.Event.start_charge_response_data)
        StartChargeResponseData(super::super::charge_point_gateway_format::StartChargeResponseData),
        // @@protoc_insertion_point(oneof_field:event.Event.ev_charge_status_data)
        EvChargeStatusData(super::super::charge_point_gateway_format::EVChargingStatusData),
        // @@protoc_insertion_point(oneof_field:event.Event.stop_charge_request_data)
        StopChargeRequestData(super::super::charge_point_gateway_format::StopChargeRequestData),
        // @@protoc_insertion_point(oneof_field:event.Event.stop_charge_response_data)
        StopChargeResponseData(super::super::charge_point_gateway_format::StopChargeResponseData),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Event as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new_2::<Data>("Event.data", 1234567)
        }
    }
}

///  Events types
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:event.EventType)
pub enum EventType {
    // @@protoc_insertion_point(enum_value:event.EventType.CHARGING_STATUS)
    CHARGING_STATUS = 0,
    // @@protoc_insertion_point(enum_value:event.EventType.SERVICE_REQUEST_ACK)
    SERVICE_REQUEST_ACK = 1,
    // @@protoc_insertion_point(enum_value:event.EventType.SERVICE_DELIVERY_ACK)
    SERVICE_DELIVERY_ACK = 2,
    // @@protoc_insertion_point(enum_value:event.EventType.SERVICE_REQUESTED)
    SERVICE_REQUESTED = 3,
    // @@protoc_insertion_point(enum_value:event.EventType.SERVICE_DELIVERED)
    SERVICE_DELIVERED = 4,
    // @@protoc_insertion_point(enum_value:event.EventType.STOP_CHARGE_REQUEST)
    STOP_CHARGE_REQUEST = 5,
    // @@protoc_insertion_point(enum_value:event.EventType.STOP_CHARGE_RESPONSE)
    STOP_CHARGE_RESPONSE = 6,
    // @@protoc_insertion_point(enum_value:event.EventType.IDENTITY_CHALLENGE)
    IDENTITY_CHALLENGE = 7,
    // @@protoc_insertion_point(enum_value:event.EventType.IDENTITY_RESPONSE)
    IDENTITY_RESPONSE = 8,
    // @@protoc_insertion_point(enum_value:event.EventType.RECEIVE_CHAIN_EVENT)
    RECEIVE_CHAIN_EVENT = 9,
    // @@protoc_insertion_point(enum_value:event.EventType.EMIT_SHOW_INFO)
    EMIT_SHOW_INFO = 10,
    // @@protoc_insertion_point(enum_value:event.EventType.GET_BALANCE)
    GET_BALANCE = 11,
    // @@protoc_insertion_point(enum_value:event.EventType.GET_BALANCE_ACK)
    GET_BALANCE_ACK = 12,
    // @@protoc_insertion_point(enum_value:event.EventType.GET_PK)
    GET_PK = 13,
    // @@protoc_insertion_point(enum_value:event.EventType.GET_PK_ACK)
    GET_PK_ACK = 14,
    // @@protoc_insertion_point(enum_value:event.EventType.REPUBLISH_DID)
    REPUBLISH_DID = 15,
    // @@protoc_insertion_point(enum_value:event.EventType.REPUBLISH_DID_ACK)
    REPUBLISH_DID_ACK = 16,
    // @@protoc_insertion_point(enum_value:event.EventType.RECONNECT)
    RECONNECT = 17,
    // @@protoc_insertion_point(enum_value:event.EventType.RECONNECT_ACK)
    RECONNECT_ACK = 18,
    // @@protoc_insertion_point(enum_value:event.EventType.PEER_CONNECTED)
    PEER_CONNECTED = 19,
    // @@protoc_insertion_point(enum_value:event.EventType.PEER_SUBSCRIBED)
    PEER_SUBSCRIBED = 20,
    // @@protoc_insertion_point(enum_value:event.EventType.PEER_CONNECTION_FAILED)
    PEER_CONNECTION_FAILED = 21,
    // @@protoc_insertion_point(enum_value:event.EventType.PEER_SUBSCRIPTION_FAILED)
    PEER_SUBSCRIPTION_FAILED = 22,
    // @@protoc_insertion_point(enum_value:event.EventType.BOOT_NOTIFICATION_REQUEST)
    BOOT_NOTIFICATION_REQUEST = 23,
    // @@protoc_insertion_point(enum_value:event.EventType.LOG)
    LOG = 24,
    // @@protoc_insertion_point(enum_value:event.EventType.AUTHORIZE_REQUEST)
    AUTHORIZE_REQUEST = 25,
    // @@protoc_insertion_point(enum_value:event.EventType.AUTHORIZE_REQUEST_ACK)
    AUTHORIZE_REQUEST_ACK = 26,
    // @@protoc_insertion_point(enum_value:event.EventType.CHECK_AVAILABILITY_REQUEST)
    CHECK_AVAILABILITY_REQUEST = 27,
    // @@protoc_insertion_point(enum_value:event.EventType.CHECK_AVAILABILITY_RESPONSE)
    CHECK_AVAILABILITY_RESPONSE = 28,
    // @@protoc_insertion_point(enum_value:event.EventType.START_CHARGE_REQUEST)
    START_CHARGE_REQUEST = 29,
    // @@protoc_insertion_point(enum_value:event.EventType.START_CHARGE_RESPONSE)
    START_CHARGE_RESPONSE = 30,
    // @@protoc_insertion_point(enum_value:event.EventType.EV_CHARGE_STATUS)
    EV_CHARGE_STATUS = 31,
}

impl ::protobuf::Enum for EventType {
    const NAME: &'static str = "EventType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventType> {
        match value {
            0 => ::std::option::Option::Some(EventType::CHARGING_STATUS),
            1 => ::std::option::Option::Some(EventType::SERVICE_REQUEST_ACK),
            2 => ::std::option::Option::Some(EventType::SERVICE_DELIVERY_ACK),
            3 => ::std::option::Option::Some(EventType::SERVICE_REQUESTED),
            4 => ::std::option::Option::Some(EventType::SERVICE_DELIVERED),
            5 => ::std::option::Option::Some(EventType::STOP_CHARGE_REQUEST),
            6 => ::std::option::Option::Some(EventType::STOP_CHARGE_RESPONSE),
            7 => ::std::option::Option::Some(EventType::IDENTITY_CHALLENGE),
            8 => ::std::option::Option::Some(EventType::IDENTITY_RESPONSE),
            9 => ::std::option::Option::Some(EventType::RECEIVE_CHAIN_EVENT),
            10 => ::std::option::Option::Some(EventType::EMIT_SHOW_INFO),
            11 => ::std::option::Option::Some(EventType::GET_BALANCE),
            12 => ::std::option::Option::Some(EventType::GET_BALANCE_ACK),
            13 => ::std::option::Option::Some(EventType::GET_PK),
            14 => ::std::option::Option::Some(EventType::GET_PK_ACK),
            15 => ::std::option::Option::Some(EventType::REPUBLISH_DID),
            16 => ::std::option::Option::Some(EventType::REPUBLISH_DID_ACK),
            17 => ::std::option::Option::Some(EventType::RECONNECT),
            18 => ::std::option::Option::Some(EventType::RECONNECT_ACK),
            19 => ::std::option::Option::Some(EventType::PEER_CONNECTED),
            20 => ::std::option::Option::Some(EventType::PEER_SUBSCRIBED),
            21 => ::std::option::Option::Some(EventType::PEER_CONNECTION_FAILED),
            22 => ::std::option::Option::Some(EventType::PEER_SUBSCRIPTION_FAILED),
            23 => ::std::option::Option::Some(EventType::BOOT_NOTIFICATION_REQUEST),
            24 => ::std::option::Option::Some(EventType::LOG),
            25 => ::std::option::Option::Some(EventType::AUTHORIZE_REQUEST),
            26 => ::std::option::Option::Some(EventType::AUTHORIZE_REQUEST_ACK),
            27 => ::std::option::Option::Some(EventType::CHECK_AVAILABILITY_REQUEST),
            28 => ::std::option::Option::Some(EventType::CHECK_AVAILABILITY_RESPONSE),
            29 => ::std::option::Option::Some(EventType::START_CHARGE_REQUEST),
            30 => ::std::option::Option::Some(EventType::START_CHARGE_RESPONSE),
            31 => ::std::option::Option::Some(EventType::EV_CHARGE_STATUS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EventType] = &[
        EventType::CHARGING_STATUS,
        EventType::SERVICE_REQUEST_ACK,
        EventType::SERVICE_DELIVERY_ACK,
        EventType::SERVICE_REQUESTED,
        EventType::SERVICE_DELIVERED,
        EventType::STOP_CHARGE_REQUEST,
        EventType::STOP_CHARGE_RESPONSE,
        EventType::IDENTITY_CHALLENGE,
        EventType::IDENTITY_RESPONSE,
        EventType::RECEIVE_CHAIN_EVENT,
        EventType::EMIT_SHOW_INFO,
        EventType::GET_BALANCE,
        EventType::GET_BALANCE_ACK,
        EventType::GET_PK,
        EventType::GET_PK_ACK,
        EventType::REPUBLISH_DID,
        EventType::REPUBLISH_DID_ACK,
        EventType::RECONNECT,
        EventType::RECONNECT_ACK,
        EventType::PEER_CONNECTED,
        EventType::PEER_SUBSCRIBED,
        EventType::PEER_CONNECTION_FAILED,
        EventType::PEER_SUBSCRIPTION_FAILED,
        EventType::BOOT_NOTIFICATION_REQUEST,
        EventType::LOG,
        EventType::AUTHORIZE_REQUEST,
        EventType::AUTHORIZE_REQUEST_ACK,
        EventType::CHECK_AVAILABILITY_REQUEST,
        EventType::CHECK_AVAILABILITY_RESPONSE,
        EventType::START_CHARGE_REQUEST,
        EventType::START_CHARGE_RESPONSE,
        EventType::EV_CHARGE_STATUS,
    ];
}

impl ::protobuf::EnumFull for EventType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EventType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EventType {
    fn default() -> Self {
        EventType::CHARGING_STATUS
    }
}

impl EventType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EventType>("EventType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17base_event_format.proto\x12\x05event\x1a!charge_point_gateway_form\
    at.proto\x1a\x18p2p_message_format.proto\"\xa6\x11\n\x05Event\x12+\n\x08\
    event_id\x18\x01\x20\x01(\x0e2\x10.event.EventTypeR\x07eventId\x12K\n\
    \x14charging_status_data\x18\x02\x20\x01(\x0b2\x17.p2p.ChargingStatusDat\
    aH\0R\x12chargingStatusData\x12?\n\x10service_ack_data\x18\x03\x20\x01(\
    \x0b2\x13.p2p.ServiceAckDataH\0R\x0eserviceAckData\x12Q\n\x16service_req\
    uested_data\x18\x04\x20\x01(\x0b2\x19.p2p.ServiceRequestedDataH\0R\x14se\
    rviceRequestedData\x12Q\n\x16service_delivered_data\x18\x05\x20\x01(\x0b\
    2\x19.p2p.ServiceDeliveredDataH\0R\x14serviceDeliveredData\x12?\n\x10sto\
    p_charge_data\x18\x06\x20\x01(\x0b2\x13.p2p.StopChargeDataH\0R\x0estopCh\
    argeData\x12P\n\x15stop_charge_resp_data\x18\x07\x20\x01(\x0b2\x1b.p2p.S\
    topChargeResponseDataH\0R\x12stopChargeRespData\x12T\n\x17identity_chall\
    enge_data\x18\x08\x20\x01(\x0b2\x1a.p2p.IdentityChallengeDataH\0R\x15ide\
    ntityChallengeData\x12Q\n\x16identity_response_data\x18\t\x20\x01(\x0b2\
    \x19.p2p.IdentityResponseDataH\0R\x14identityResponseData\x12?\n\x10chai\
    n_event_data\x18\n\x20\x01(\x0b2\x13.p2p.ChainEventDataH\0R\x0echainEven\
    tData\x12F\n\x13emit_show_info_data\x18\x0b\x20\x01(\x0b2\x15.p2p.EmitSh\
    owInfoDataH\0R\x10emitShowInfoData\x12I\n\x14get_balance_ack_data\x18\
    \x0c\x20\x01(\x0b2\x16.p2p.GetBalanceAckDataH\0R\x11getBalanceAckData\
    \x12:\n\x0fget_pk_ack_data\x18\r\x20\x01(\x0b2\x11.p2p.GetPKAckDataH\0R\
    \x0cgetPkAckData\x12H\n\x12republish_ack_data\x18\x0e\x20\x01(\x0b2\x18.\
    p2p.RePublishDIDAckDataH\0R\x10republishAckData\x12E\n\x12reconnect_ack_\
    data\x18\x0f\x20\x01(\x0b2\x15.p2p.ReconnectAckDataH\0R\x10reconnectAckD\
    ata\x12[\n\x1aservice_requested_ack_data\x18\x10\x20\x01(\x0b2\x1c.p2p.S\
    erviceRequestedAckDataH\0R\x17serviceRequestedAckData\x12k\n\x1eboot_not\
    ification_request_data\x18\x11\x20\x01(\x0b2$.gateway.BootNotificationRe\
    questDataH\0R\x1bbootNotificationRequestData\x12-\n\x08log_data\x18\x12\
    \x20\x01(\x0b2\x10.gateway.LogDataH\0R\x07logData\x12U\n\x16authorize_re\
    quest_data\x18\x13\x20\x01(\x0b2\x1d.gateway.AuthorizeRequestDataH\0R\
    \x14authorizeRequestData\x12X\n\x17authorize_response_data\x18\x14\x20\
    \x01(\x0b2\x1e.gateway.AuthorizeResponseDataH\0R\x15authorizeResponseDat\
    a\x12n\n\x1fcheck_availability_request_data\x18\x15\x20\x01(\x0b2%.gatew\
    ay.CheckAvailabilityRequestDataH\0R\x1ccheckAvailabilityRequestData\x12q\
    \n\x20check_availability_response_data\x18\x16\x20\x01(\x0b2&.gateway.Ch\
    eckAvailabilityResponseDataH\0R\x1dcheckAvailabilityResponseData\x12\\\n\
    \x19start_charge_request_data\x18\x18\x20\x01(\x0b2\x1f.gateway.StartCha\
    rgeRequestDataH\0R\x16startChargeRequestData\x12_\n\x1astart_charge_resp\
    onse_data\x18\x19\x20\x01(\x0b2\x20.gateway.StartChargeResponseDataH\0R\
    \x17startChargeResponseData\x12R\n\x15ev_charge_status_data\x18\x1a\x20\
    \x01(\x0b2\x1d.gateway.EVChargingStatusDataH\0R\x12evChargeStatusData\
    \x12Y\n\x18stop_charge_request_data\x18\x1b\x20\x01(\x0b2\x1e.gateway.St\
    opChargeRequestDataH\0R\x15stopChargeRequestData\x12\\\n\x19stop_charge_\
    response_data\x18\x1c\x20\x01(\x0b2\x1f.gateway.StopChargeResponseDataH\
    \0R\x16stopChargeResponseDataB\x06\n\x04data*\xe7\x05\n\tEventType\x12\
    \x13\n\x0fCHARGING_STATUS\x10\0\x12\x17\n\x13SERVICE_REQUEST_ACK\x10\x01\
    \x12\x18\n\x14SERVICE_DELIVERY_ACK\x10\x02\x12\x15\n\x11SERVICE_REQUESTE\
    D\x10\x03\x12\x15\n\x11SERVICE_DELIVERED\x10\x04\x12\x17\n\x13STOP_CHARG\
    E_REQUEST\x10\x05\x12\x18\n\x14STOP_CHARGE_RESPONSE\x10\x06\x12\x16\n\
    \x12IDENTITY_CHALLENGE\x10\x07\x12\x15\n\x11IDENTITY_RESPONSE\x10\x08\
    \x12\x17\n\x13RECEIVE_CHAIN_EVENT\x10\t\x12\x12\n\x0eEMIT_SHOW_INFO\x10\
    \n\x12\x0f\n\x0bGET_BALANCE\x10\x0b\x12\x13\n\x0fGET_BALANCE_ACK\x10\x0c\
    \x12\n\n\x06GET_PK\x10\r\x12\x0e\n\nGET_PK_ACK\x10\x0e\x12\x11\n\rREPUBL\
    ISH_DID\x10\x0f\x12\x15\n\x11REPUBLISH_DID_ACK\x10\x10\x12\r\n\tRECONNEC\
    T\x10\x11\x12\x11\n\rRECONNECT_ACK\x10\x12\x12\x12\n\x0ePEER_CONNECTED\
    \x10\x13\x12\x13\n\x0fPEER_SUBSCRIBED\x10\x14\x12\x1a\n\x16PEER_CONNECTI\
    ON_FAILED\x10\x15\x12\x1c\n\x18PEER_SUBSCRIPTION_FAILED\x10\x16\x12\x1d\
    \n\x19BOOT_NOTIFICATION_REQUEST\x10\x17\x12\x07\n\x03LOG\x10\x18\x12\x15\
    \n\x11AUTHORIZE_REQUEST\x10\x19\x12\x19\n\x15AUTHORIZE_REQUEST_ACK\x10\
    \x1a\x12\x1e\n\x1aCHECK_AVAILABILITY_REQUEST\x10\x1b\x12\x1f\n\x1bCHECK_\
    AVAILABILITY_RESPONSE\x10\x1c\x12\x18\n\x14START_CHARGE_REQUEST\x10\x1d\
    \x12\x19\n\x15START_CHARGE_RESPONSE\x10\x1e\x12\x14\n\x10EV_CHARGE_STATU\
    S\x10\x1fBSZQgithub.com/peaqnetwork/peaq-network-ev-charging-message-for\
    mat/golang/event;eventJ\xb0\x18\n\x06\x12\x04\0\0X\x01\n\x08\n\x01\x0c\
    \x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x0e\n\x08\n\x01\x08\x12\
    \x03\x03\0h\n\t\n\x02\x08\x0b\x12\x03\x03\0h\n\t\n\x02\x03\0\x12\x03\x05\
    \0+\n\t\n\x02\x03\x01\x12\x03\x06\0\"\n\x1a\n\x02\x05\0\x12\x04\t\03\x01\
    \x1a\x0e\x20Events\x20types\n\n\n\n\x03\x05\0\x01\x12\x03\t\x05\x0e\n\
    \x0b\n\x04\x05\0\x02\0\x12\x03\n\x02\x16\n\x0c\n\x05\x05\0\x02\0\x01\x12\
    \x03\n\x02\x11\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\n\x14\x15\n\x0b\n\x04\
    \x05\0\x02\x01\x12\x03\x0b\x02\x1a\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\
    \x0b\x02\x15\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x0b\x18\x19\n\x0b\n\
    \x04\x05\0\x02\x02\x12\x03\x0c\x02\x1b\n\x0c\n\x05\x05\0\x02\x02\x01\x12\
    \x03\x0c\x02\x16\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x0c\x19\x1a\n\x0b\
    \n\x04\x05\0\x02\x03\x12\x03\r\x02\x18\n\x0c\n\x05\x05\0\x02\x03\x01\x12\
    \x03\r\x02\x13\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\r\x16\x17\n\x0b\n\
    \x04\x05\0\x02\x04\x12\x03\x0e\x02\x18\n\x0c\n\x05\x05\0\x02\x04\x01\x12\
    \x03\x0e\x02\x13\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0e\x16\x17\n\x0b\
    \n\x04\x05\0\x02\x05\x12\x03\x0f\x02\x1a\n\x0c\n\x05\x05\0\x02\x05\x01\
    \x12\x03\x0f\x02\x15\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0f\x18\x19\n\
    \x0b\n\x04\x05\0\x02\x06\x12\x03\x10\x02\x1b\n\x0c\n\x05\x05\0\x02\x06\
    \x01\x12\x03\x10\x02\x16\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x10\x19\
    \x1a\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x11\x02\x19\n\x0c\n\x05\x05\0\x02\
    \x07\x01\x12\x03\x11\x02\x14\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x11\
    \x17\x18\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x12\x02\x18\n\x0c\n\x05\x05\0\
    \x02\x08\x01\x12\x03\x12\x02\x13\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\
    \x12\x16\x17\n$\n\x04\x05\0\x02\t\x12\x03\x15\x02\x1a\x1a\x17\x20For\x20\
    substarte's\x20event\n\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x15\x02\x15\n\
    \x0c\n\x05\x05\0\x02\t\x02\x12\x03\x15\x18\x19\n\x20\n\x04\x05\0\x02\n\
    \x12\x03\x17\x02\x16\x1a\x13\x20For\x20simulator\x20log\n\n\x0c\n\x05\
    \x05\0\x02\n\x01\x12\x03\x17\x02\x10\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\
    \x17\x13\x15\n$\n\x04\x05\0\x02\x0b\x12\x03\x1a\x02\x13\x1a\x17\x20For\
    \x20simulator\x20actions\n\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x1a\x02\
    \r\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x1a\x10\x12\n\x0b\n\x04\x05\0\
    \x02\x0c\x12\x03\x1b\x02\x17\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x1b\
    \x02\x11\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x1b\x14\x16\n\x0b\n\x04\
    \x05\0\x02\r\x12\x03\x1c\x02\x0e\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x1c\
    \x02\x08\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x1c\x0b\r\n\x0b\n\x04\x05\0\
    \x02\x0e\x12\x03\x1d\x02\x12\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x1d\
    \x02\x0c\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x1d\x0f\x11\n\x0b\n\x04\
    \x05\0\x02\x0f\x12\x03\x1e\x02\x15\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\
    \x1e\x02\x0f\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\x03\x1e\x12\x14\n\x0b\n\
    \x04\x05\0\x02\x10\x12\x03\x1f\x02\x19\n\x0c\n\x05\x05\0\x02\x10\x01\x12\
    \x03\x1f\x02\x13\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x1f\x16\x18\n\x0b\
    \n\x04\x05\0\x02\x11\x12\x03\x20\x02\x11\n\x0c\n\x05\x05\0\x02\x11\x01\
    \x12\x03\x20\x02\x0b\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x20\x0e\x10\n\
    \x0b\n\x04\x05\0\x02\x12\x12\x03!\x02\x15\n\x0c\n\x05\x05\0\x02\x12\x01\
    \x12\x03!\x02\x0f\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03!\x12\x14\n\"\n\
    \x04\x05\0\x02\x13\x12\x03$\x02\x16\x1a\x15\x20For\x20charmev\x20actions\
    \n\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03$\x02\x10\n\x0c\n\x05\x05\0\x02\
    \x13\x02\x12\x03$\x13\x15\n\x0b\n\x04\x05\0\x02\x14\x12\x03%\x02\x17\n\
    \x0c\n\x05\x05\0\x02\x14\x01\x12\x03%\x02\x11\n\x0c\n\x05\x05\0\x02\x14\
    \x02\x12\x03%\x14\x16\n\x0b\n\x04\x05\0\x02\x15\x12\x03&\x02\x1e\n\x0c\n\
    \x05\x05\0\x02\x15\x01\x12\x03&\x02\x18\n\x0c\n\x05\x05\0\x02\x15\x02\
    \x12\x03&\x1b\x1d\n\x0b\n\x04\x05\0\x02\x16\x12\x03'\x02\x20\n\x0c\n\x05\
    \x05\0\x02\x16\x01\x12\x03'\x02\x1a\n\x0c\n\x05\x05\0\x02\x16\x02\x12\
    \x03'\x1d\x1f\n*\n\x04\x05\0\x02\x17\x12\x03*\x02!\x1a\x1d\x20Charge\x20\
    point\x20gateway\x20events\n\n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03*\x02\
    \x1b\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03*\x1e\x20\n\x0b\n\x04\x05\0\
    \x02\x18\x12\x03+\x02\x0b\n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03+\x02\x05\
    \n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03+\x08\n\n\x0b\n\x04\x05\0\x02\x19\
    \x12\x03,\x02\x19\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03,\x02\x13\n\x0c\n\
    \x05\x05\0\x02\x19\x02\x12\x03,\x16\x18\n\x0b\n\x04\x05\0\x02\x1a\x12\
    \x03-\x02\x1d\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03-\x02\x17\n\x0c\n\x05\
    \x05\0\x02\x1a\x02\x12\x03-\x1a\x1c\n\x0b\n\x04\x05\0\x02\x1b\x12\x03.\
    \x02\"\n\x0c\n\x05\x05\0\x02\x1b\x01\x12\x03.\x02\x1c\n\x0c\n\x05\x05\0\
    \x02\x1b\x02\x12\x03.\x1f!\n\x0b\n\x04\x05\0\x02\x1c\x12\x03/\x02#\n\x0c\
    \n\x05\x05\0\x02\x1c\x01\x12\x03/\x02\x1d\n\x0c\n\x05\x05\0\x02\x1c\x02\
    \x12\x03/\x20\"\n\x0b\n\x04\x05\0\x02\x1d\x12\x030\x02\x1c\n\x0c\n\x05\
    \x05\0\x02\x1d\x01\x12\x030\x02\x16\n\x0c\n\x05\x05\0\x02\x1d\x02\x12\
    \x030\x19\x1b\n\x0b\n\x04\x05\0\x02\x1e\x12\x031\x02\x1d\n\x0c\n\x05\x05\
    \0\x02\x1e\x01\x12\x031\x02\x17\n\x0c\n\x05\x05\0\x02\x1e\x02\x12\x031\
    \x1a\x1c\n\x0b\n\x04\x05\0\x02\x1f\x12\x032\x02\x18\n\x0c\n\x05\x05\0\
    \x02\x1f\x01\x12\x032\x02\x12\n\x0c\n\x05\x05\0\x02\x1f\x02\x12\x032\x15\
    \x17\n\n\n\x02\x04\0\x12\x045\0X\x01\n\n\n\x03\x04\0\x01\x12\x035\x08\r\
    \n\x0b\n\x04\x04\0\x02\0\x12\x036\x02\x19\n\x0c\n\x05\x04\0\x02\0\x06\
    \x12\x036\x02\x0b\n\x0c\n\x05\x04\0\x02\0\x01\x12\x036\x0c\x14\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x036\x17\x18\n\x0c\n\x04\x04\0\x08\0\x12\x047\
    \x02W\x03\n\x0c\n\x05\x04\0\x08\0\x01\x12\x037\x08\x0c\n\x0b\n\x04\x04\0\
    \x02\x01\x12\x038\x044\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x038\x04\x1a\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x038\x1b/\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03823\n\x0b\n\x04\x04\0\x02\x02\x12\x039\x04,\n\x0c\n\x05\x04\0\
    \x02\x02\x06\x12\x039\x04\x16\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x039\x17\
    '\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x039*+\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03:\x048\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03:\x04\x1c\n\x0c\n\x05\
    \x04\0\x02\x03\x01\x12\x03:\x1d3\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03:6\
    7\n\x0b\n\x04\x04\0\x02\x04\x12\x03;\x048\n\x0c\n\x05\x04\0\x02\x04\x06\
    \x12\x03;\x04\x1c\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03;\x1d3\n\x0c\n\
    \x05\x04\0\x02\x04\x03\x12\x03;67\n\x0b\n\x04\x04\0\x02\x05\x12\x03<\x04\
    ,\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03<\x04\x16\n\x0c\n\x05\x04\0\x02\
    \x05\x01\x12\x03<\x17'\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03<*+\n\x0b\n\
    \x04\x04\0\x02\x06\x12\x03=\x049\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03=\
    \x04\x1e\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03=\x1f4\n\x0c\n\x05\x04\0\
    \x02\x06\x03\x12\x03=78\n\x0b\n\x04\x04\0\x02\x07\x12\x03>\x04:\n\x0c\n\
    \x05\x04\0\x02\x07\x06\x12\x03>\x04\x1d\n\x0c\n\x05\x04\0\x02\x07\x01\
    \x12\x03>\x1e5\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03>89\n\x0b\n\x04\x04\
    \0\x02\x08\x12\x03?\x048\n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03?\x04\x1c\
    \n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03?\x1d3\n\x0c\n\x05\x04\0\x02\x08\
    \x03\x12\x03?67\n\x0b\n\x04\x04\0\x02\t\x12\x03A\x04-\n\x0c\n\x05\x04\0\
    \x02\t\x06\x12\x03A\x04\x16\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03A\x17'\n\
    \x0c\n\x05\x04\0\x02\t\x03\x12\x03A*,\n\x0b\n\x04\x04\0\x02\n\x12\x03B\
    \x042\n\x0c\n\x05\x04\0\x02\n\x06\x12\x03B\x04\x18\n\x0c\n\x05\x04\0\x02\
    \n\x01\x12\x03B\x19,\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03B/1\n\x0b\n\x04\
    \x04\0\x02\x0b\x12\x03D\x044\n\x0c\n\x05\x04\0\x02\x0b\x06\x12\x03D\x04\
    \x19\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03D\x1a.\n\x0c\n\x05\x04\0\x02\
    \x0b\x03\x12\x03D13\n\x0b\n\x04\x04\0\x02\x0c\x12\x03E\x04*\n\x0c\n\x05\
    \x04\0\x02\x0c\x06\x12\x03E\x04\x14\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\
    \x03E\x15$\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03E')\n\x0b\n\x04\x04\0\
    \x02\r\x12\x03F\x044\n\x0c\n\x05\x04\0\x02\r\x06\x12\x03F\x04\x1b\n\x0c\
    \n\x05\x04\0\x02\r\x01\x12\x03F\x1c.\n\x0c\n\x05\x04\0\x02\r\x03\x12\x03\
    F13\n\x0b\n\x04\x04\0\x02\x0e\x12\x03G\x041\n\x0c\n\x05\x04\0\x02\x0e\
    \x06\x12\x03G\x04\x18\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03G\x19+\n\x0c\
    \n\x05\x04\0\x02\x0e\x03\x12\x03G.0\n\x0b\n\x04\x04\0\x02\x0f\x12\x03I\
    \x04@\n\x0c\n\x05\x04\0\x02\x0f\x06\x12\x03I\x04\x1f\n\x0c\n\x05\x04\0\
    \x02\x0f\x01\x12\x03I\x20:\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x03I=?\n.\n\
    \x04\x04\0\x02\x10\x12\x03L\x04L\x1a!\x20Charge\x20Point\x20Gateway\x20e\
    vent\x20data\n\n\x0c\n\x05\x04\0\x02\x10\x06\x12\x03L\x04'\n\x0c\n\x05\
    \x04\0\x02\x10\x01\x12\x03L(F\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x03LIK\n\
    \x0b\n\x04\x04\0\x02\x11\x12\x03M\x04\"\n\x0c\n\x05\x04\0\x02\x11\x06\
    \x12\x03M\x04\x13\n\x0c\n\x05\x04\0\x02\x11\x01\x12\x03M\x14\x1c\n\x0c\n\
    \x05\x04\0\x02\x11\x03\x12\x03M\x1f!\n\x0b\n\x04\x04\0\x02\x12\x12\x03N\
    \x04=\n\x0c\n\x05\x04\0\x02\x12\x06\x12\x03N\x04\x20\n\x0c\n\x05\x04\0\
    \x02\x12\x01\x12\x03N!7\n\x0c\n\x05\x04\0\x02\x12\x03\x12\x03N:<\n\x0b\n\
    \x04\x04\0\x02\x13\x12\x03O\x04?\n\x0c\n\x05\x04\0\x02\x13\x06\x12\x03O\
    \x04!\n\x0c\n\x05\x04\0\x02\x13\x01\x12\x03O\"9\n\x0c\n\x05\x04\0\x02\
    \x13\x03\x12\x03O<>\n\x0b\n\x04\x04\0\x02\x14\x12\x03P\x04N\n\x0c\n\x05\
    \x04\0\x02\x14\x06\x12\x03P\x04(\n\x0c\n\x05\x04\0\x02\x14\x01\x12\x03P)\
    H\n\x0c\n\x05\x04\0\x02\x14\x03\x12\x03PKM\n\x0b\n\x04\x04\0\x02\x15\x12\
    \x03Q\x04P\n\x0c\n\x05\x04\0\x02\x15\x06\x12\x03Q\x04)\n\x0c\n\x05\x04\0\
    \x02\x15\x01\x12\x03Q*J\n\x0c\n\x05\x04\0\x02\x15\x03\x12\x03QMO\n\x0b\n\
    \x04\x04\0\x02\x16\x12\x03R\x04B\n\x0c\n\x05\x04\0\x02\x16\x06\x12\x03R\
    \x04\"\n\x0c\n\x05\x04\0\x02\x16\x01\x12\x03R#<\n\x0c\n\x05\x04\0\x02\
    \x16\x03\x12\x03R?A\n\x0b\n\x04\x04\0\x02\x17\x12\x03S\x04D\n\x0c\n\x05\
    \x04\0\x02\x17\x06\x12\x03S\x04#\n\x0c\n\x05\x04\0\x02\x17\x01\x12\x03S$\
    >\n\x0c\n\x05\x04\0\x02\x17\x03\x12\x03SAC\n\x0b\n\x04\x04\0\x02\x18\x12\
    \x03T\x04<\n\x0c\n\x05\x04\0\x02\x18\x06\x12\x03T\x04\x20\n\x0c\n\x05\
    \x04\0\x02\x18\x01\x12\x03T!6\n\x0c\n\x05\x04\0\x02\x18\x03\x12\x03T9;\n\
    \x0b\n\x04\x04\0\x02\x19\x12\x03U\x04@\n\x0c\n\x05\x04\0\x02\x19\x06\x12\
    \x03U\x04!\n\x0c\n\x05\x04\0\x02\x19\x01\x12\x03U\":\n\x0c\n\x05\x04\0\
    \x02\x19\x03\x12\x03U=?\n\x0b\n\x04\x04\0\x02\x1a\x12\x03V\x04B\n\x0c\n\
    \x05\x04\0\x02\x1a\x06\x12\x03V\x04\"\n\x0c\n\x05\x04\0\x02\x1a\x01\x12\
    \x03V#<\n\x0c\n\x05\x04\0\x02\x1a\x03\x12\x03V?Ab\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::with_capacity(2);
        deps.push(super::charge_point_gateway_format::file_descriptor());
        deps.push(super::p2p_message_format::file_descriptor());
        let mut messages = ::std::vec::Vec::with_capacity(1);
        messages.push(Event::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::with_capacity(1);
        enums.push(EventType::generated_enum_descriptor_data());
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
